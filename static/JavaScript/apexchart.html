<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>PiMon Sensor Graph</title>

    <link href="../../assets/styles.css" rel="stylesheet" />

    <style>
      
        #chart {
      max-width: 1000px;
      margin: 35px auto;
    }
      
    </style>

    <script>
      window.Promise ||
        document.write(
          '<script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"><\/script>'
        )
      window.Promise ||
        document.write(
          '<script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20171210/classList.min.js"><\/script>'
        )
      window.Promise ||
        document.write(
          '<script src="https://cdn.jsdelivr.net/npm/findindex_polyfill_mdn"><\/script>'
        )
    </script>

    
    <script src="../../../dist/apexcharts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

    <script>
      // Replace Math.random() with a pseudo-random number generator to get reproducible results in e2e tests
      // Based on https://gist.github.com/blixt/f17b47c62508be59987b
      var _seed = 42
      Math.random = function() {
        _seed = (_seed * 16807) % 2147483647
        return (_seed - 1) / 2147483646
      }
    </script>

    <script>

  // The Start Time is 0, which represents 0 seconds into the recording
  // The empty dictionairy is established to hold the X:Y information
  var StartTime = 0;
  var data = []

  // The Tick interval represents 1 unit at a time; seconds
  // X Axis Range is how many units are going to display on the graph
  var TICKINTERVAL = 1
  let XAXISRANGE = 15

  var testcyclenumber = (XAXISRANGE*1000)

  function getDayWiseTimeSeries(baseval, count, yrange) {
    
    var i = -1;

    while (i < count) {
      var x = baseval;
      var y = Math.floor(Math.random() * (yrange.max - yrange.min + 1)) + yrange.min;
  
      data.push({
        x, y
      });

      StartTime = baseval
      baseval += TICKINTERVAL;
      i++;
    }
  }
  
  getDayWiseTimeSeries(StartTime, XAXISRANGE, {
    min: 10,
    max: 90
  })
  
  function getNewSeries(baseval, yrange) {
    var NextTimeChecked = baseval + TICKINTERVAL;
    StartTime = NextTimeChecked;
  
  for(var i = 0; i<= data.length - XAXISRANGE; i++) {
      // IMPORTANT
      // we reset the x and y of the data which is out of drawing area
      // to prevent memory leaks
      data[i].x = NextTimeChecked - XAXISRANGE
      data[i].y = 0
    }

    data.push({
      x: NextTimeChecked,
      y: Math.floor(Math.random() * (yrange.max - yrange.min + 1)) + yrange.min
    })


  }
  
  function resetData(){
    // Alternatively, you can also reset the data at certain intervals to prevent creating a huge series 
    data = data.slice(data.length - XAXISRANGE, data.length);
  }
  </script>
  </head>

  <body>
     <div id="chart"></div>

    <script>
      


        // These are formating guidelines that the chart has to adhere to
        // They need to be placed above where the chart is initialized
        // This allows the chart to know how it needs to be rendered
        var options = {

          series: [{
            data: data.slice()
            }],

          chart: {
            id: 'realtime',
            height: 350,
            type: 'line',
            animations: {
              enabled: true,
              easing: 'linear',
              dynamicAnimation: {
                speed: 1000
                }
              },

            toolbar: {
              show: false
              },

            zoom: {
              enabled: false
              }

            },

          // This looks stupid with dynamic graph animations. if you enable it, turn off the animation
          // even then, it looks wonky
          dataLabels: {
            enabled: false,
            enabledOnSeries: undefined,
            formatter: function (val, opts) {
                return val
            },
            textAnchor: 'middle',
            distributed: false,
            offsetX: 0,
            offsetY: 0,
            style: {
                fontSize: '14px',
                fontFamily: 'Helvetica, Arial, sans-serif',
                fontWeight: 'bold',
                colors: undefined
            },
            background: {
              enabled: true,
              foreColor: '#fff',
              padding: 4,
              borderRadius: 2,
              borderWidth: 1,
              borderColor: '#fff',
              opacity: 0.9,
              dropShadow: {
                enabled: false,
                top: 1,
                left: 1,
                blur: 1,
                color: '#000',
                opacity: 0.45
              }
            },
            dropShadow: {
                enabled: false,
                top: 1,
                left: 1,
                blur: 1,
                color: '#000',
                opacity: 0.45
            }
          },

          stroke: {
            curve: 'smooth'
            },

          title: {
            text: 'Sensor Graph',
            align: 'left'
            },

          markers: {
            size: 0
            },

          xaxis: {
            // Set to category instead of numeric to remove float values
            type: 'category',
            axisTicks: {
              show: true,
              borderType: 'solid',
              color: '#78909C',
              height: 6,
              offsetX: 0,
              offsetY: 0
              },

              tickAmount: XAXISRANGE,
              tickPlacement: 'on',
              min: undefined,
              max: undefined,
              range: undefined,
              floating: false,
              position: 'bottom',
              title: {
                  text: 'seconds',
                  offsetX: 0,
                  offsetY: 0,
                  style: {
                      color: undefined,
                      fontSize: '12px',
                      fontFamily: 'Helvetica, Arial, sans-serif',
                      fontWeight: 600,
                      cssClass: 'apexcharts-xaxis-title',
                      },
                  },
            },

          yaxis: {
            // changing this value to undefined makes the max change. its dynamic
            max: 100
            },

          legend: {
            show: true
            },

          };



        // The Following Establishes the graph and renders it on the screen
        var chart = new ApexCharts(document.querySelector("#chart"), options);
        chart.render();
      
      
        window.setInterval(function () {

        // This is the function called once every 1000 (1 second)
        // Anything that you would want done to the graph continuously should be stated here

        // This function gets new data for the graph
        getNewSeries(StartTime, {
          min: 10,
          max: 90
        })
        
        // This function actually changes the graph data
        chart.updateSeries([{
          data: data
        }])

      }, 1000)


      // This runs once every x axis cycle
      // If the axis size is 10 seconds, it runs every 10 seconds
      // It resets the data array so that it doesnt clog memory
      window.setInterval(function () {
        
        getNewSeries(StartTime, {
          NULL
        })
      
        chart.updateSeries([{
          data: data
        }])

        resetData()
      }, testcyclenumber)


    </script>

    
  </body>
</html>